The Perturbations List:
________________________________________________________________________________________________________________________________________________

The perturbations list allows you to specify complex perturbations to be performed on constraints.
You may generate all combinations of perturbations from a set, enforce some perturbations to be in all combinations, and do much more.

If you don't want to perform any perturbations, keep the list empty. Otherwise, add elements from one of two forms:


1. Regular Perturbations:

They are of the following structure:

["REG", [[("a", "b",...), [j,...,n], 1/0], [("c", "d",...), [p,...,k], 1/0]],...]

The first element specifies the following elements are to be present in all perturbations generated:
The following elements specify the perturbations done and are built by lists of the following structure:

[("a", "b",...), [j,...,n], 1/0]

The first element is a tuple of all the components that this perturbation refers to.
The second element specifies in which experiments the perturbations take place.
The third element specifies whether the components shall be knocked out or overexpressed.


2. Combination Perturbations:

They are part of the structure.

["COMB", [[("a1",..., "an"), ("b1",..., "bk"),...], comb, [p,...,k], 1/0]]

The first element specifies that the program will generate combinations of perturbations from the given set, such that every file
will have one of the combinations generated.

The following element specifies the perturbations to be generated in each file and is structured as:

[[("a1",..., "an"), ("b1",..., "bk"),...], comb, [p,...,k], 1/0]

The first element is a list of tuples of components, such that each tuple functions as a single element in the combinations generated.
The second element is a natural number that specifies how many elements there may be in a single combination.
The third element specifies in which experiments the perturbations take place.
The fourth element specifies whether the components shall be knocked out or overexpressed.
________________________________________________________________________________________________________________________________________________

Important Detail: If the list provided can generate perturbations with internal contradictions (such as the same component,
being KOed and FEed in the same experiment), these perturbations will be ignored.

Protip: to save time, when you want to refer to all system components for your perturbations (for example,
all combinations of 2 system components), you may use the expression: f.tuplize(COMPONENTS).
________________________________________________________________________________________________________________________________________________

The Constraint Expressions:
________________________________________________________________________________________________________________________________________________

The list of constraint expressions allows you to define logical expressions that conjoin the experimental constraints of a cabn.
Using this list, you may define which hour constraints you want to be satisfied and at which timestamps they are allowed.

Using this information, the program will automatically generate the proper expression for the information given.
and add it to every file generated.

The list should be written in the following format:

CONSTRAINT_EXPRESSIONS = {n1 : {k1 : ("t1-t2", ...),
                                k2 : ("t*1-t*2", ...),
                                k3 : ("t**1-t**2", ...), ...},

                          n2 : {p1 : ("h1-h2", ...),
                                p2 : ("h*1-h*2", ...),
                                p3 : ("h**1-h**2", ...), ...}, ...}
                          .
                          .
                          .

The keys of the large external dictionary are experiment numbers, such that every experiment corresponds to an expression.

The keys of the inner dictionaries are numbers of hour constraints, which correspond to tuples of the form:

("t1-t2", ...)

Every element in the tuple is a range of timestamps where the constraint can be satisfied.